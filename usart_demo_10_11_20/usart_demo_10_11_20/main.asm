//Настраиваем прерывания
.org 0
jmp reset
.org 0x1C //когда UDR становится пустым, то здесь возникает прерывание (см. даташит)
jmp nextData

reset:

// настраиваем указатель стека
ldi r16,high(RAMEND)
out SPH,r16
ldi r16,low(RAMEND)
out SPL,r16

//Настраиваем скорость работы USART 9600
ldi r16,0
out UBRRH,r16
ldi r16,51
out UBRRL,r16

// UDRIE разрешает прерывание, если UDR пустой
//
// TXEN разрешение на передачу
// TXCIE включает прерываение на передачу
//
// RXEN разрешение на прием
// RXCIE включает прерывание на прием
//
ldi r16,(1<<UDRIE)|(1<<TXEN)//|(1<<RXEN)
out UCSRB,r16

// Z - регистровая пара, которой соответствует что-то типа R30-R31
// ZH - старший байт (например R30)
// ZL - младший байт (например R31)
// флеш память адресуется словами (2 байта), поэтому умножаем адреса на 2
// lpm берет байт, который лежит по адресу, который записан в ZH-ZL
// "+" увеличит число в Z после выполнения команды
// sei ставит бит прерываний в регистр состояний, без этого прерывания работать не будут
// когда прерывание произошло, то этот бит ставится обратно в 0, пока не вызовется reti, тогда прерывания снова станут доступны
ldi ZH,high(text*2)
ldi ZL,low(text*2)
lpm r16,Z+
out UDR,r16
sei
end: rjmp end

// если конец строки, то в Z перезаписываем адрес на начало строки, иначе ничего не делаем (переходим в конец и выходим из прерывания)
// brne - branch not equal
// cpi + brne - сравнение на равенство через вычитание и бит переноса
nextData:
lpm r16,Z+
out UDR,r16

cpi ZH,high(endtext*2)
brne endData
cpi ZL,low(endtext*2)
brne endData

ldi ZH,high(text*2)
ldi ZL,low(text*2)

endData: reti

text:
.db "Hello, friends! "
endtext:
